# Deer River App - Cursor Rules

## üö® CRITICAL: Always Backup Before Major Changes
- **Before ANY schema changes** (adding/removing columns, tables, indexes)
- **Before data migrations** (changing data types, restructuring data)
- **Before major feature deployments** that modify database structure
- **Before bulk data operations** (imports, updates, deletions)

### Backup Methods:
1. **AWS RDS Automated Backups** (Recommended)
2. **Manual Database Export** via `pg_dump`
3. **Quick Data Verification** via `/api/db-status`

## üìã Development Workflow

### 1. Planning Phase
- **REQUIRED**: Write a detailed PLAN before any code change >5 lines
- Include: context, approach, expected outcomes, potential risks
- For complex changes: create a design document or diagram

### 2. Code Quality Sequence (ALWAYS run in this order)
```bash
npm run lint          # Check code style and catch errors
npm run typecheck     # Verify TypeScript types (excludes test files)
npm run test          # Run unit and integration tests
npm run build         # Ensure production build works
```

**Note**: The typecheck script excludes test files to focus on production code quality. Test files have their own validation through Jest.

### 2.1 TypeScript Validation Rules
- **MANDATORY**: All TypeScript errors MUST be fixed before deployment
- **Array Types**: Always specify array types explicitly (e.g., `Array<Record<string, string | number>>`)
- **Dynamic Styling**: When using dynamic CSS (like `gridTemplateColumns`), use inline styles with proper TypeScript casting
- **Optional Chaining**: Use `?.` and `!` operators carefully - ensure types are properly defined
- **Record Types**: For dynamic object properties, use `Record<string, T>` instead of `any`
- **Build Validation**: If `npm run build` fails, fix ALL errors before pushing to any branch

### 3. Package Management
- **ALWAYS use `npm ci`** for installs (not `npm install`)
- This ensures reproducible builds and faster CI/CD
- Use `npm install` only for adding new dependencies

### 3.1 Terminal Command Rules
- **NO PAGINATION**: Always append `| head -20` or `--no-paginate` to commands that might produce long output
- **Git Commands**: Use `git log --oneline -10`, `git diff --no-pager`, `git show --no-pager`
- **AWS CLI**: Use `--no-paginate` flag for list commands
- **System Commands**: Use `ps aux | head -20`, `netstat -tulpn | head -20`
- **Docker Commands**: Use `docker logs --tail 50`, `docker ps --format "table {{.Names}}\t{{.Status}}"`
- **Prevent Terminal Hangs**: Never run commands that use `less`, `more`, or similar pagers

### 4. Database Changes
- **For ANY DB-affecting changes:**
  1. Propose Prisma migration with detailed description
  2. Run `prisma migrate diff` in dry-run mode first
  3. Test migration on development database
  4. Document rollback procedure
- **Schema changes require:**
  - Migration file with clear comments
  - Data validation after migration
  - API endpoint testing
  - Frontend component updates if needed

### 5. API Development
- **For API changes:**
  1. Update API documentation
  2. Test `/api/health` endpoint
  3. Add/update API tests
  4. Verify error handling
  5. Test with both valid and invalid inputs
- **API Route Pattern:**
  ```typescript
  const dbUrl = process.env.DATABASE_URL?.trim()
  if (!dbUrl || (!dbUrl.startsWith('postgresql://') && !dbUrl.startsWith('postgres://'))) {
    return NextResponse.json({ success: false, error: 'Database connection not configured' }, { status: 500 })
  }
  const prisma = new PrismaClient({ datasources: { db: { url: dbUrl } } })
  ```

### 6. Database Connection Rules
- **Development**: Can connect to shared AWS database for testing
- **Production**: Never make direct schema changes to production
- **Local Testing**: Use `.env.local` for local development
- **Schema Changes**: Always test on development branch first

### 7. Pull Request Requirements
Every PR must include:
- **Context**: Why this change is needed
- **Approach**: How the problem is being solved
- **Diffs**: Key changes made
- **Risks**: Potential issues and mitigation strategies
- **Rollback Plan**: How to revert if issues arise
- **Testing**: What was tested and how

## üõ†Ô∏è Technical Standards

### Code Quality
- **TypeScript**: Strict mode enabled, no `any` types
- **ESLint**: All rules must pass before commit
- **Testing**: New features require tests
- **Documentation**: Complex logic must be commented

### Common TypeScript Pitfalls to Avoid
- **Dynamic Arrays**: Always type arrays explicitly (`Array<Record<string, T>>` not `[]`)
- **CSS-in-JS**: Use inline styles for dynamic values, not template literals in className
- **Optional Properties**: Use `?.` and `!` carefully, ensure types are defined
- **Record Types**: Use `Record<string, T>` for dynamic object properties
- **Grid Layouts**: Use `style={{ gridTemplateColumns: 'repeat(n, 1fr)' }}` for dynamic grids
- **Type Assertions**: Cast types explicitly (`as number`) when necessary
- **Build Validation**: Always run `npm run build` before pushing

### Common Terminal Pitfalls to Avoid
- **Pagination Hangs**: Never run commands without pagination control (`| head -20`, `--no-paginate`)
- **Long Output**: Always limit output to prevent terminal from getting stuck
- **Interactive Commands**: Use non-interactive flags (`--yes`, `--no-prompt`) when available
- **Background Processes**: Use `nohup` or `&` for long-running commands
- **Command Timeouts**: Set reasonable timeouts for potentially slow commands

### File Organization
- **Components**: Place in `src/components/`
- **API Routes**: Place in `src/app/api/`
- **Utilities**: Place in `src/lib/`
- **Types**: Define interfaces for all data structures

### Error Handling
- **API Routes**: Always return consistent error format
- **Frontend**: Graceful degradation with fallback data
- **Database**: Proper connection cleanup in finally blocks

## üöÄ Deployment Process

### Pre-Deployment Checklist
- [ ] All tests pass locally
- [ ] Build succeeds without warnings
- [ ] Database migrations tested
- [ ] API endpoints verified
- [ ] Frontend functionality tested
- [ ] No console errors in browser

### TypeScript & Build Validation (MANDATORY)
- [ ] `npm run lint` passes with 0 errors
- [ ] `npm run typecheck` passes with 0 errors  
- [ ] `npm run build` completes successfully
- [ ] All TypeScript types are properly defined
- [ ] No `any` types in production code
- [ ] Dynamic CSS uses inline styles with proper typing
- [ ] Array and object types are explicitly declared
- [ ] All imports are properly resolved
- [ ] No missing dependencies in package.json

**CRITICAL**: If ANY step fails, fix the issue before pushing to any branch

### Amplify Deployment
- **Development Branch**: Auto-deploys on push
- **Production Branch**: Manual deployment after testing
- **Rollback**: Use AWS Amplify console if needed

## üîç Debugging Guidelines

### When Issues Arise
1. **Check logs**: Both browser console and server logs
2. **Verify API**: Test endpoints directly with curl/Postman
3. **Database**: Check connection and data integrity
4. **Environment**: Verify all environment variables
5. **Dependencies**: Ensure all packages are installed

### Common Issues
- **API 404s**: Check Prisma client initialization
- **Build Failures**: Run lint/typecheck locally first
- **Database Errors**: Verify schema matches Prisma models
- **TypeScript Errors**: Check interface definitions

## üìä Monitoring

### Health Checks
- **API Health**: `/api/health` endpoint
- **Database Status**: `/api/db-status` endpoint
- **Build Status**: Check Amplify console
- **Error Tracking**: Monitor browser console and server logs

### Performance
- **Build Time**: Monitor Amplify build duration
- **API Response**: Check response times
- **Database Queries**: Optimize slow queries
- **Bundle Size**: Keep frontend bundle optimized

## üéØ Project-Specific Rules

### Deer River App Context
- **Fantasy Town Management**: AD&D 1e inspired
- **Population Tracking**: People, factions, relationships
- **Resource Management**: Economic and social systems
- **Data Integrity**: Critical for game mechanics

### Key Features
- **Demographics**: Species-based analysis with D&D age categories
- **Faction System**: Complex relationship tracking
- **Location Management**: Buildings and places
- **Interactive Maps**: Visual representation of town

### Data Models
- **Person**: Citizens with species, age, occupation
- **Faction**: Political groups with relationships
- **Location**: Buildings and places
- **Membership**: Person-faction relationships
- **Opinions**: Interpersonal and faction relationships

## ‚ö†Ô∏è Critical Warnings

1. **NEVER** make schema changes directly in production
2. **ALWAYS** test changes on development branch first
3. **ALWAYS** backup database before major changes
4. **ALWAYS** verify data integrity after changes
5. **NEVER** commit code that doesn't pass all quality checks

## üìö Resources

- **Prisma Docs**: https://www.prisma.io/docs
- **Next.js Docs**: https://nextjs.org/docs
- **Amplify Docs**: https://docs.aws.amazon.com/amplify
- **TypeScript Docs**: https://www.typescriptlang.org/docs
- **Tailwind CSS**: https://tailwindcss.com/docs

---

**Remember**: This is a complex application managing critical game data. Always prioritize data integrity and user experience over speed of development.

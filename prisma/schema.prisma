generator client {
  provider = "prisma-client-js"
  engineType = "binary"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Person {
  id       String @id @default(cuid())
  name     String
  species  String
  age      Int?
  occupation String?
  householdId  String?
  household    Household? @relation(fields: [householdId], references: [id])
  livesAtId    String
  livesAt      Location @relation("LivesAt", fields: [livesAtId], references: [id])
  worksAtId    String?
  worksAt      Location? @relation("WorksAt", fields: [worksAtId], references: [id])
  tags         String
  notes        String?

  opinionsFrom Opinion[] @relation("From")
  opinionsTo   Opinion[] @relation("To")
  resourceEntries TownResourceLedger[]
  
  // New relationship models
  memberships PersonFactionMembership[]
  factionOpinions FactionOpinion[]
}

model Faction {
  id          String @id @default(cuid())
  name        String @unique
  motto       String?
  description String?
  color       String?
  
  // New relationship models
  memberships PersonFactionMembership[]
  opinions   FactionOpinion[]
}

model Household {
  id          String @id @default(cuid())
  name        String
  description String?
  members     Person[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Location {
  id          String @id @default(cuid())
  name        String @unique
  kind        String // Temporary field until schema is properly updated
  description String?
  x           Float?
  y           Float?
  residents   Person[] @relation("LivesAt")
  workers     Person[] @relation("WorksAt")
}

model Opinion {
  id        String @id @default(cuid())
  fromId    String
  from      Person @relation("From", fields: [fromId], references: [id])
  toId      String
  to        Person @relation("To", fields: [toId], references: [id])
  score     Int
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fromId, toId], name: "Opinion_fromPersonId_toPersonId_key")
}

model ResourceCategory {
  id          String @id @default(cuid())
  name        String
  description String?
  unit        String
  ledgerEntries TownResourceLedger[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model TownResourceLedger {
  id          String @id @default(cuid())
  categoryId  String
  category    ResourceCategory @relation(fields: [categoryId], references: [id])
  amount      Float
  change      Float
  reason      String?
  personId    String?
  person      Person? @relation(fields: [personId], references: [id])
  createdAt   DateTime @default(now())
}

model EventLog {
  id        String @id @default(cuid())
  event     String
  details   String?
  personId  String?
  createdAt DateTime @default(now())
}

/** One row per person↔faction relationship */
model PersonFactionMembership {
  id          String   @id @default(cuid())
  personId    String
  factionId   String
  role        String?      // "member", "captain", "leader", etc.
  isPrimary   Boolean @default(false)
  joinedAt    DateTime @default(now())
  leftAt      DateTime?    // null if active

  /** Personal alignment with THIS faction's current direction:
   * -100 (actively subversive) … 0 (neutral/indifferent) … +100 (strongly aligned)
   */
  alignment   Int      @default(0)

  /** Optional: how publicly they show that alignment (0..100). */
  openness    Int      @default(50)

  /** Optional notes */
  notes       String?

  person   Person  @relation(fields: [personId], references: [id])
  faction  Faction @relation(fields: [factionId], references: [id])

  @@index([personId, factionId])
  @@unique([personId, factionId, joinedAt]) // allows re-joining later
}

/** Feelings about factions regardless of membership */
model FactionOpinion {
  id        String   @id @default(cuid())
  personId  String
  factionId String
  score     Int      // -100..100
  reason    String?
  updatedAt DateTime @updatedAt

  person  Person  @relation(fields:[personId], references:[id])
  faction Faction @relation(fields:[factionId], references:[id])

  @@unique([personId, factionId], name: "personId_factionId")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
  engineType    = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Person {
  id               String                   @id @default(cuid())
  name             String
  species          String
  age              Int?
  occupation       String?
  factionId        String?
  householdId      String?
  livesAtId        String
  worksAtId        String?
  tags             String
  notes            String?
  fromEventEffects EventEffect[]            @relation("FromEventEffects")
  toEventEffects   EventEffect[]            @relation("ToEventEffects")
  cohorts          PersonCohort[]
  fromOverrides    PersonRelationOverride[] @relation("FromOverrides")
  toOverrides      PersonRelationOverride[] @relation("ToOverrides")
  fromRelations    PersonRelation[]         @relation("FromRelations")
  toRelations      PersonRelation[]         @relation("ToRelations")
}

model Faction {
  id          String  @id @default(cuid())
  name        String  @unique
  motto       String?
  description String?
  color       String?
}

model Household {
  id         String  @id @default(cuid())
  name       String?
  locationId String
  notes      String?
}

model Location {
  id       String  @id @default(cuid())
  name     String
  kind     String
  parentId String?
  x        Float?  @db.Real
  y        Float?  @db.Real
  address  String?
  notes    String?
}

model Opinion {
  id           String   @id @default(cuid())
  fromPersonId String
  toPersonId   String
  score        Int
  reason       String?
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamp(6)

  @@unique([fromPersonId, toPersonId], name: "Opinion_fromPersonId_toPersonId_key")
}

model ResourceCategory {
  id    String  @id @default(cuid())
  name  String  @unique
  unit  String
  notes String?
}

model TownResourceLedger {
  id                 String   @id @default(cuid())
  date               DateTime @db.Timestamp(6)
  resourceCategoryId String
  delta              Float    @db.Real
  reason             String
  sourcePersonId     String?
  sourceFactionId    String?
}

model EventLog {
  id         String   @id @default(cuid())
  date       DateTime @db.Timestamp(6)
  title      String
  details    String?
  locationId String?
}

/// * One row per person↔faction relationship
model PersonFactionMembership {
  id        String    @id @default(cuid())
  personId  String
  factionId String
  role      String    @default("member")
  isPrimary Boolean   @default(false)
  /// * Personal alignment with THIS faction's current direction:
  /// * -100 (actively subversive) … 0 (neutral/indifferent) … +100 (strongly aligned)
  alignment Int       @default(0)
  /// * Optional: how publicly they show that alignment (0..100).
  openness  Int       @default(50)
  joinedAt  DateTime  @default(now()) @db.Timestamp(6)
  leftAt    DateTime? @db.Timestamp(6)
  /// * Optional notes
  notes     String?
}

/// * Feelings about factions regardless of membership
model FactionOpinion {
  id        String   @id @default(cuid())
  personId  String
  factionId String
  score     Int
  reason    String?
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamp(6)

  @@unique([personId, factionId], name: "personId_factionId")
}

model Alliance {
  id         String    @id
  factionAId String
  factionBId String
  type       String
  stance     String
  notes      String?
  startedAt  DateTime? @db.Timestamp(6)

  @@unique([factionAId, factionBId])
}

/// * Cohorts for grouping people (e.g., ORIGINAL_RESIDENT, MERCHANT, GUARD)
model Cohort {
  id              String          @id @default(cuid())
  name            String          @unique
  description     String?
  color           String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  eventEffects    EventEffect[]   @relation("SourceCohort")
  targetEffects   EventEffect[]   @relation("TargetCohort")
  people          PersonCohort[]
  seedingPolicies SeedingPolicy[] @relation("SourceCohort")
  targetPolicies  SeedingPolicy[] @relation("TargetCohort")

  @@map("cohorts")
}

/// * Junction table for person-cohort relationships
model PersonCohort {
  id       String   @id @default(cuid())
  personId String
  cohortId String
  joinedAt DateTime @default(now())
  notes    String?
  cohort   Cohort   @relation(fields: [cohortId], references: [id], onDelete: Cascade)
  person   Person   @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([personId, cohortId])
  @@map("person_cohorts")
}

/// * Seeding policies for automatic relationship generation
model SeedingPolicy {
  id               String   @id @default(cuid())
  name             String
  description      String?
  sourceCohortId   String
  targetCohortId   String
  domain           String
  probability      Float
  involvementLevel String
  scoreMin         Int
  scoreMax         Int
  worldSeed        String?
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  sourceCohort     Cohort   @relation("SourceCohort", fields: [sourceCohortId], references: [id])
  targetCohort     Cohort   @relation("TargetCohort", fields: [targetCohortId], references: [id])

  @@map("seeding_policies")
}

/// * Enhanced person relations with provenance tracking
model PersonRelation {
  id           String                @id @default(cuid())
  fromPersonId String
  toPersonId   String
  domain       String
  involvement  String
  score        Int
  provenance   String                @default("MANUAL")
  sourceRef    Json?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  auditLogs    PersonRelationAudit[]
  fromPerson   Person                @relation("FromRelations", fields: [fromPersonId], references: [id], onDelete: Cascade)
  toPerson     Person                @relation("ToRelations", fields: [toPersonId], references: [id], onDelete: Cascade)

  @@unique([fromPersonId, toPersonId, domain])
  @@map("person_relations")
}

/// * Overrides for specific person pairs
model PersonRelationOverride {
  id           String   @id @default(cuid())
  fromPersonId String
  toPersonId   String
  domain       String
  involvement  String?
  score        Int?
  reason       String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  fromPerson   Person   @relation("FromOverrides", fields: [fromPersonId], references: [id], onDelete: Cascade)
  toPerson     Person   @relation("ToOverrides", fields: [toPersonId], references: [id], onDelete: Cascade)

  @@unique([fromPersonId, toPersonId, domain])
  @@map("person_relation_overrides")
}

/// * Events that affect relationships
model Event {
  id          String        @id @default(cuid())
  name        String
  description String?
  eventType   String
  startDate   DateTime
  endDate     DateTime?
  isActive    Boolean       @default(true)
  worldSeed   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  effects     EventEffect[]

  @@map("events")
}

/// * Effects that events have on relationships
model EventEffect {
  id             String   @id @default(cuid())
  eventId        String
  sourceCohortId String?
  targetCohortId String?
  fromPersonId   String?
  toPersonId     String?
  domain         String?
  effectType     String
  value          Float
  decayPerDay    Float?
  scope          String
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  event          Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  fromPerson     Person?  @relation("FromEventEffects", fields: [fromPersonId], references: [id])
  sourceCohort   Cohort?  @relation("SourceCohort", fields: [sourceCohortId], references: [id])
  targetCohort   Cohort?  @relation("TargetCohort", fields: [targetCohortId], references: [id])
  toPerson       Person?  @relation("ToEventEffects", fields: [toPersonId], references: [id])

  @@map("event_effects")
}

/// * Audit trail for relationship changes
model PersonRelationAudit {
  id         String         @id @default(cuid())
  relationId String
  action     String
  oldValues  Json?
  newValues  Json?
  changedBy  String?
  reason     String?
  createdAt  DateTime       @default(now())
  relation   PersonRelation @relation(fields: [relationId], references: [id], onDelete: Cascade)

  @@map("person_relation_audit")
}

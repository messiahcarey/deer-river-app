generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
  engineType    = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Person {
  id               String                   @id @default(cuid())
  name             String
  species          String
  age              Int?
  occupation       String?
  factionId        String?
  householdId      String?
  livesAtId        String
  worksAtId        String?
  workplaceId      String? // New v3 workplace relationship
  tags             String
  notes            String?
  fromEventEffects EventEffect[]            @relation("FromEventEffects")
  toEventEffects   EventEffect[]            @relation("ToEventEffects")
  cohorts          PersonCohort[]
  fromOverrides    PersonRelationOverride[] @relation("FromOverrides")
  toOverrides      PersonRelationOverride[] @relation("ToOverrides")
  fromRelations    PersonRelation[]         @relation("FromRelations")
  toRelations      PersonRelation[]         @relation("ToRelations")
  
  // Relationship fields
  livesAt          Location?                @relation("PersonLivesAt", fields: [livesAtId], references: [id])
  worksAt          Location?                @relation("PersonWorksAt", fields: [worksAtId], references: [id])
  memberships      PersonFactionMembership[]
  
  // New v3 relationships
  household        Household?               @relation("HouseholdResidents", fields: [householdId], references: [id])
  workplace        Workplace?               @relation("WorkplaceWorkers", fields: [workplaceId], references: [id])
  involvementScore InvolvementScore?
  loyaltyScores    LoyaltyScore[]
  fromRelationships Relationship[]          @relation("FromRelationships")
  toRelationships   Relationship[]          @relation("ToRelationships")
}

model Faction {
  id          String  @id @default(cuid())
  name        String  @unique
  motto       String?
  description String?
  color       String?
  
  // Reverse relationships
  memberships PersonFactionMembership[]
}

model Household {
  id         String  @id @default(cuid())
  name       String?
  locationId String
  notes      String?
  
  // New v3 relationships
  residents  Person[] @relation("HouseholdResidents")
}

model Workplace {
  id         String  @id @default(cuid())
  name       String
  type       String? // shop, mill, marina, tavern, guard-post, caravan
  location   String?
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  // New v3 relationships
  workers    Person[] @relation("WorkplaceWorkers")
}

model Location {
  id       String  @id @default(cuid())
  name     String
  kind     String
  parentId String?
  x        Float?  @db.Real
  y        Float?  @db.Real
  address  String?
  notes    String?
  
  // Reverse relationships
  residents Person[] @relation("PersonLivesAt")
  workers   Person[] @relation("PersonWorksAt")
}

model Opinion {
  id           String   @id @default(cuid())
  fromPersonId String
  toPersonId   String
  score        Int
  reason       String?
  updatedAt    DateTime @default(now()) @updatedAt @db.Timestamp(6)

  @@unique([fromPersonId, toPersonId], name: "Opinion_fromPersonId_toPersonId_key")
}

model ResourceCategory {
  id    String  @id @default(cuid())
  name  String  @unique
  unit  String
  notes String?
}

model TownResourceLedger {
  id                 String   @id @default(cuid())
  date               DateTime @db.Timestamp(6)
  resourceCategoryId String
  delta              Float    @db.Real
  reason             String
  sourcePersonId     String?
  sourceFactionId    String?
}

model EventLog {
  id         String   @id @default(cuid())
  date       DateTime @db.Timestamp(6)
  title      String
  details    String?
  locationId String?
}

/// * One row per person↔faction relationship
model PersonFactionMembership {
  id        String    @id @default(cuid())
  personId  String
  factionId String
  role      String    @default("member")
  isPrimary Boolean   @default(false)
  /// * Personal alignment with THIS faction's current direction:
  /// * -100 (actively subversive) … 0 (neutral/indifferent) … +100 (strongly aligned)
  alignment Int       @default(0)
  /// * Optional: how publicly they show that alignment (0..100).
  openness  Int       @default(50)
  joinedAt  DateTime  @default(now()) @db.Timestamp(6)
  leftAt    DateTime? @db.Timestamp(6)
  /// * Optional notes
  notes     String?
  
  // Relationship fields
  person   Person  @relation(fields: [personId], references: [id])
  faction  Faction @relation(fields: [factionId], references: [id])
}

/// * Feelings about factions regardless of membership
model FactionOpinion {
  id        String   @id @default(cuid())
  personId  String
  factionId String
  score     Int
  reason    String?
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamp(6)

  @@unique([personId, factionId], name: "personId_factionId")
}

model Alliance {
  id         String    @id
  factionAId String
  factionBId String
  type       String
  stance     String
  notes      String?
  startedAt  DateTime? @db.Timestamp(6)

  @@unique([factionAId, factionBId])
}

/// * Cohorts for grouping people (e.g., ORIGINAL_RESIDENT, MERCHANT, GUARD)
model Cohort {
  id              String          @id @default(cuid())
  name            String          @unique
  description     String?
  color           String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  eventEffects    EventEffect[]   @relation("SourceCohort")
  targetEffects   EventEffect[]   @relation("TargetCohort")
  people          PersonCohort[]
  seedingPolicies SeedingPolicy[] @relation("SourceCohort")
  targetPolicies  SeedingPolicy[] @relation("TargetCohort")

  @@map("cohorts")
}

/// * Junction table for person-cohort relationships
model PersonCohort {
  id       String   @id @default(cuid())
  personId String
  cohortId String
  joinedAt DateTime @default(now())
  notes    String?
  cohort   Cohort   @relation(fields: [cohortId], references: [id], onDelete: Cascade)
  person   Person   @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([personId, cohortId])
  @@map("person_cohorts")
}

/// * Seeding policies for automatic relationship generation
model SeedingPolicy {
  id               String   @id @default(cuid())
  name             String
  description      String?
  sourceCohortId   String
  targetCohortId   String
  domain           String
  probability      Float
  involvementLevel String
  scoreMin         Int
  scoreMax         Int
  worldSeed        String?
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  sourceCohort     Cohort   @relation("SourceCohort", fields: [sourceCohortId], references: [id])
  targetCohort     Cohort   @relation("TargetCohort", fields: [targetCohortId], references: [id])

  @@map("seeding_policies")
}

/// * Enhanced person relations with provenance tracking
model PersonRelation {
  id           String                @id @default(cuid())
  fromPersonId String
  toPersonId   String
  domain       String
  involvement  String
  score        Int
  provenance   String                @default("MANUAL")
  sourceRef    Json?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  auditLogs    PersonRelationAudit[]
  fromPerson   Person                @relation("FromRelations", fields: [fromPersonId], references: [id], onDelete: Cascade)
  toPerson     Person                @relation("ToRelations", fields: [toPersonId], references: [id], onDelete: Cascade)

  @@unique([fromPersonId, toPersonId, domain])
  @@map("person_relations")
}

/// * Overrides for specific person pairs
model PersonRelationOverride {
  id           String   @id @default(cuid())
  fromPersonId String
  toPersonId   String
  domain       String
  involvement  String?
  score        Int?
  reason       String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  fromPerson   Person   @relation("FromOverrides", fields: [fromPersonId], references: [id], onDelete: Cascade)
  toPerson     Person   @relation("ToOverrides", fields: [toPersonId], references: [id], onDelete: Cascade)

  @@unique([fromPersonId, toPersonId, domain])
  @@map("person_relation_overrides")
}

/// * Events that affect relationships
model Event {
  id          String        @id @default(cuid())
  name        String
  description String?
  eventType   String
  startDate   DateTime
  endDate     DateTime?
  isActive    Boolean       @default(true)
  worldSeed   String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  effects     EventEffect[]

  @@map("events")
}

/// * Effects that events have on relationships
model EventEffect {
  id             String   @id @default(cuid())
  eventId        String
  sourceCohortId String?
  targetCohortId String?
  fromPersonId   String?
  toPersonId     String?
  domain         String?
  effectType     String
  value          Float
  decayPerDay    Float?
  scope          String
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  event          Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  fromPerson     Person?  @relation("FromEventEffects", fields: [fromPersonId], references: [id])
  sourceCohort   Cohort?  @relation("SourceCohort", fields: [sourceCohortId], references: [id])
  targetCohort   Cohort?  @relation("TargetCohort", fields: [targetCohortId], references: [id])
  toPerson       Person?  @relation("ToEventEffects", fields: [toPersonId], references: [id])

  @@map("event_effects")
}

/// * Audit trail for relationship changes
model PersonRelationAudit {
  id         String         @id @default(cuid())
  relationId String
  action     String
  oldValues  Json?
  newValues  Json?
  changedBy  String?
  reason     String?
  createdAt  DateTime       @default(now())
  relation   PersonRelation @relation(fields: [relationId], references: [id], onDelete: Cascade)

  @@map("person_relation_audit")
}

// New v3 Models for Involvement & Loyalty Model v3

// Relationship types enum
enum RelationshipKind {
  KINSHIP
  HOUSEHOLD
  WORK
  FACTION
  PATRONAGE
  FRIENDSHIP
  RIVALRY
  COMMAND
  MERCHANT
  EVENT_IMPACT
}

// Generalized relationships table for v3
model Relationship {
  id         String           @id @default(cuid())
  srcId      String
  dstId      String
  kind       RelationshipKind
  directed   Boolean          @default(false)
  weight     Float            @default(0.5) // 0.0 to 1.0
  sentiment  Float            @default(0.0) // -1.0 to 1.0
  metadata   Json?            @default("{}")
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  
  // Relationships
  src        Person           @relation("FromRelationships", fields: [srcId], references: [id], onDelete: Cascade)
  dst        Person           @relation("ToRelationships", fields: [dstId], references: [id], onDelete: Cascade)
  
  @@unique([srcId, dstId, kind])
  @@map("relationships")
}

// Involvement scores
model InvolvementScore {
  personId   String   @id
  score      Float    // 0.0 to 1.0
  window     String   @default("90d")
  breakdown  Json?    @default("{}")
  updatedAt  DateTime @default(now())
  
  // Relationships
  person     Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  
  @@map("involvement_scores")
}

// Loyalty scores (target can be faction or person)
model LoyaltyScore {
  personId   String
  targetId   String
  score      Float    // 0.0 to 1.0
  window     String   @default("180d")
  breakdown  Json?    @default("{}")
  updatedAt  DateTime @default(now())
  
  // Relationships
  person     Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  
  @@id([personId, targetId])
  @@map("loyalty_scores")
}

// Enhanced events table for v3
model EventV3 {
  id          String   @id @default(cuid())
  name        String
  category    String?  // festival, raid, policy, disaster, market
  startsAt    DateTime?
  endsAt      DateTime?
  impact      Json?    @default("{}") // e.g., { "faction_boost": {"Guard": +0.1}, "sentiment": {"Corven": -0.2} }
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("events_v3")
}
